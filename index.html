<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio X-Ray - XIRR & Asset Allocation Analyzer</title>
    
    <!-- Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lucide@0.344.0/dist/umd/lucide.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    
    <!-- Fonts & Styles -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+JP:wght@300;400;500;700&display=swap');
        
        body { 
            font-family: 'Inter', 'Noto Sans JP', sans-serif; 
            background-color: #f1f5f9; 
            color: #1e293b;
            overflow-x: hidden;
        }
        
        .app-container { 
            max-width: 1400px; 
            margin: 0 auto; 
            padding: 1.5rem; 
        }

        /* Card & Chart Styles */
        .chart-card { 
            background: white; 
            border-radius: 0.75rem; 
            border: 1px solid #e2e8f0; 
            padding: 1rem; 
            box-shadow: 0 1px 2px rgba(0,0,0,0.05); 
            display: flex; 
            flex-direction: column; 
            height: 320px;
            transition: all 0.2s;
        }
        .chart-card:hover {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            transform: translateY(-2px);
        }
        .chart-container { 
            position: relative; 
            flex: 1; 
            width: 100%; 
            min-height: 0;
        }

        /* XIRR Gauge Style */
        .xirr-gauge-container {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            height: 100%;
            position: relative;
        }
        .xirr-value {
            font-size: 3rem;
            font-weight: 800;
            background: linear-gradient(135deg, #2563eb, #06b6d4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Table Styles */
        .data-table-container {
            overflow-x: auto;
            border-radius: 0.5rem;
            border: 1px solid #e2e8f0;
            background: white;
        }
        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
        }
        .data-table th {
            background: #f8fafc;
            padding: 0.75rem;
            text-align: left;
            font-weight: 600;
            color: #64748b;
            border-bottom: 1px solid #e2e8f0;
            white-space: nowrap;
        }
        .data-table td {
            padding: 0.75rem;
            border-bottom: 1px solid #f1f5f9;
        }
        .data-table tr:hover { background: #f8fafc; }
        
        .input-price {
            width: 110px;
            padding: 0.25rem 0.5rem;
            border: 1px solid #cbd5e1;
            border-radius: 0.25rem;
            text-align: right;
            font-family: 'Inter', monospace;
            transition: all 0.2s;
            font-size: 0.85rem;
        }
        .input-price:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }
        .input-price.auto-updated {
            background-color: #f0fdf4;
            border-color: #86efac;
            color: #15803d;
            font-weight: 600;
        }

        /* Log Section */
        .log-container {
            background: #1e293b;
            color: #94a3b8;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.75rem;
            padding: 1rem;
            border-radius: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 2rem;
            white-space: pre-wrap;
        }
        .log-entry { margin-bottom: 0.25rem; border-bottom: 1px solid #334155; padding-bottom: 0.25rem; }
        .log-success { color: #4ade80; }
        .log-warn { color: #facc15; }
        .log-info { color: #60a5fa; }

        /* AI Section */
        .prose-ai { font-size: 0.95rem; line-height: 1.6; }
        .prose-ai h3 { font-size: 1.1rem; font-weight: 700; color: #1e40af; margin-top: 1rem; margin-bottom: 0.5rem; }
        .prose-ai ul { list-style: disc; margin-left: 1.5rem; margin-bottom: 1rem; }
        .prose-ai strong { color: #1e3a8a; background: #dbeafe; padding: 0 4px; border-radius: 2px; }

        /* Splash */
        .splash-screen {
            position: fixed; inset: 0; z-index: 50;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .splash-screen.hidden { display: none; }

        /* Grid Layouts */
        .dashboard-grid {
            display: grid;
            gap: 1.5rem;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
        }
        .dashboard-grid.cols-3 { grid-template-columns: repeat(3, 1fr); }
        @media (max-width: 1024px) { .dashboard-grid.cols-3 { grid-template-columns: repeat(2, 1fr); } }
        @media (max-width: 640px) { .dashboard-grid.cols-3 { grid-template-columns: 1fr; } }

        /* Loading */
        .loading-overlay { background: rgba(255,255,255,0.9); backdrop-filter: blur(4px); }
    </style>
</head>
<body>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="fixed inset-0 z-[100] flex flex-col items-center justify-center hidden loading-overlay">
        <div class="animate-spin rounded-full h-12 w-12 border-4 border-blue-600 border-t-transparent mb-4"></div>
        <p class="text-lg font-bold text-slate-700 animate-pulse" id="loadingText">データ解析中...</p>
    </div>

    <!-- Splash Screen -->
    <div id="initialSplash" class="splash-screen">
        <div class="text-center p-10 max-w-2xl w-full">
            <div class="mb-6 flex justify-center">
                <div class="bg-white p-6 rounded-3xl shadow-xl border border-blue-100">
                    <i data-lucide="pie-chart" class="w-20 h-20 text-blue-600"></i>
                </div>
            </div>
            <h1 class="text-4xl font-extrabold text-slate-800 mb-3 tracking-tight">Portfolio X-Ray</h1>
            <p class="text-slate-500 mb-8 font-medium text-lg">XIRR（内部収益率）と資産配分を可視化する<br>高度な投資分析ダッシュボード</p>
            
            <div class="bg-white p-8 rounded-2xl shadow-lg border border-slate-200">
                <p class="text-sm text-slate-500 mb-4">
                    楽天証券のCSVファイルを読み込んでください<br>
                    <span class="text-xs text-slate-400">（取引履歴・資産残高ファイルをまとめて選択可）</span>
                </p>
                <label class="group relative flex items-center justify-center gap-4 w-full bg-blue-600 hover:bg-blue-700 text-white text-lg font-bold py-4 px-8 rounded-xl cursor-pointer transition-all shadow-lg hover:shadow-blue-500/30 active:scale-[0.98]">
                    <i data-lucide="upload-cloud" class="w-6 h-6"></i>
                    <span>ファイルを選択 (複数可)</span>
                    <input type="file" id="csvFileInputSplash" class="hidden" accept=".csv" multiple>
                </label>
            </div>
        </div>
    </div>

    <!-- Header -->
    <header id="appHeader" class="bg-white/95 backdrop-blur-md border-b border-slate-200 shadow-sm sticky top-0 z-40 hidden">
        <div class="max-w-[1400px] mx-auto px-4 py-2">
            <div class="flex items-center justify-between gap-4">
                <div class="flex items-center gap-2">
                    <i data-lucide="activity" class="text-blue-600 w-5 h-5"></i>
                    <span class="font-bold text-slate-700 text-lg tracking-tight">Portfolio X-Ray</span>
                </div>
                
                <div class="flex items-center gap-2">
                    <label class="btn-sm flex items-center gap-2 px-3 py-1.5 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-md text-xs font-bold cursor-pointer transition-colors">
                        <i data-lucide="upload" class="w-3.5 h-3.5"></i> 再読込
                        <input type="file" id="csvFileInputHeader" class="hidden" accept=".csv" multiple>
                    </label>
                    <button id="btnExportPdf" class="btn-sm flex items-center gap-2 px-3 py-1.5 bg-slate-700 hover:bg-slate-600 text-white rounded-md text-xs font-bold transition-colors">
                        <i data-lucide="file-down" class="w-3.5 h-3.5"></i> PDF
                    </button>
                    <button id="btnExportJson" class="btn-sm flex items-center gap-2 px-3 py-1.5 bg-emerald-600 hover:bg-emerald-500 text-white rounded-md text-xs font-bold transition-colors">
                        <i data-lucide="file-json" class="w-3.5 h-3.5"></i> JSON
                    </button>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="app-container hidden" id="mainContent">
        
        <!-- Top KPI Section -->
        <section class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
            <!-- Total XIRR Gauge -->
            <div class="chart-card md:col-span-1" style="height: 260px;">
                <h4 class="text-sm font-bold text-slate-500 uppercase tracking-wider mb-2">Portfolio XIRR</h4>
                <div class="xirr-gauge-container">
                    <canvas id="chartXirrGauge" class="absolute inset-0"></canvas>
                    <div class="z-10 text-center mt-10">
                        <div id="kpiTotalXirr" class="xirr-value">0.0%</div>
                        <p class="text-xs text-slate-400 font-medium mt-1">内部収益率 (年率)</p>
                    </div>
                </div>
            </div>
            
            <!-- Key Metrics -->
            <div class="md:col-span-3 grid grid-cols-3 gap-4">
                <div class="bg-white p-5 rounded-xl border border-slate-200 shadow-sm flex flex-col justify-center relative overflow-hidden group">
                    <div class="absolute right-0 top-0 p-4 opacity-10 group-hover:opacity-20 transition-opacity">
                        <i data-lucide="wallet" class="w-16 h-16 text-blue-600"></i>
                    </div>
                    <p class="text-xs font-bold text-slate-400 uppercase tracking-widest">現在の資産評価額</p>
                    <h3 id="kpiCurrentValue" class="text-2xl font-extrabold text-slate-800 mt-1">-</h3>
                    <p id="kpiInvested" class="text-xs text-slate-500 mt-2">累計投資額: -</p>
                </div>
                
                <div class="bg-white p-5 rounded-xl border border-slate-200 shadow-sm flex flex-col justify-center relative overflow-hidden group">
                    <div class="absolute right-0 top-0 p-4 opacity-10 group-hover:opacity-20 transition-opacity">
                        <i data-lucide="trending-up" class="w-16 h-16 text-emerald-600"></i>
                    </div>
                    <p class="text-xs font-bold text-slate-400 uppercase tracking-widest">含み損益 (評価益)</p>
                    <h3 id="kpiUnrealizedPL" class="text-2xl font-extrabold text-emerald-600 mt-1">-</h3>
                    <div class="flex items-center gap-2 mt-2">
                        <span id="kpiReturnRate" class="text-xs font-bold px-2 py-0.5 bg-emerald-100 text-emerald-700 rounded-full">-%</span>
                    </div>
                </div>
                
                <div class="bg-white p-5 rounded-xl border border-slate-200 shadow-sm flex flex-col justify-center relative overflow-hidden group">
                    <div class="absolute right-0 top-0 p-4 opacity-10 group-hover:opacity-20 transition-opacity">
                        <i data-lucide="piggy-bank" class="w-16 h-16 text-orange-600"></i>
                    </div>
                    <p class="text-xs font-bold text-slate-400 uppercase tracking-widest">確定利益 (実現損益)</p>
                    <h3 id="kpiRealizedPL" class="text-2xl font-extrabold text-orange-600 mt-1">-</h3>
                    <p id="kpiDividends" class="text-xs text-slate-500 mt-2">配当・分配金込(推定)</p>
                </div>
            </div>
        </section>

        <!-- Charts Grid 1: Asset Allocation & Strategy -->
        <h3 class="text-lg font-bold text-slate-700 mb-4 flex items-center gap-2">
            <i data-lucide="pie-chart" class="w-5 h-5 text-blue-500"></i> 資産配分と投資戦略
        </h3>
        <section class="dashboard-grid cols-3 mb-8" id="gridSection1">
            <!-- Charts will be injected here -->
        </section>

        <!-- Charts Grid 2: Performance & Trends -->
        <h3 class="text-lg font-bold text-slate-700 mb-4 flex items-center gap-2">
            <i data-lucide="line-chart" class="w-5 h-5 text-emerald-500"></i> パフォーマンス分析
        </h3>
        <section class="dashboard-grid cols-3 mb-8" id="gridSection2">
            <!-- Charts will be injected here -->
        </section>

        <!-- Simulator & Data Table -->
        <section class="mb-8 bg-white rounded-xl border border-slate-200 shadow-sm overflow-hidden">
            <div class="p-4 border-b border-slate-200 flex flex-wrap items-center justify-between gap-4 bg-slate-50">
                <div>
                    <h3 class="text-lg font-bold text-slate-800 flex items-center gap-2">
                        <i data-lucide="calculator" class="w-5 h-5 text-indigo-500"></i> 資産シミュレーター (XIRR再計算)
                    </h3>
                    <p class="text-xs text-slate-500 mt-1">※「現在単価」を修正すると、XIRRおよび資産評価額がリアルタイムで再計算されます。</p>
                </div>
                <div class="flex items-center gap-2">
                     <div class="relative">
                        <i data-lucide="search" class="w-4 h-4 absolute left-3 top-1/2 -translate-y-1/2 text-slate-400"></i>
                        <input type="text" id="tableSearch" placeholder="銘柄名で検索..." class="pl-9 pr-3 py-1.5 text-sm border border-slate-300 rounded-md focus:outline-none focus:border-blue-500 w-64">
                    </div>
                </div>
            </div>
            <div class="data-table-container max-h-[500px] overflow-y-auto">
                <table class="data-table" id="assetTable">
                    <thead class="sticky top-0 z-10 shadow-sm">
                        <tr>
                            <th>銘柄名 / ティッカー</th>
                            <th>資産クラス</th>
                            <th>戦略</th>
                            <th class="text-right">保有数量 (株/口)</th>
                            <th class="text-right">平均取得単価</th>
                            <th class="text-right bg-blue-50 border-l border-blue-100">現在単価 (編集可)</th>
                            <th class="text-right">評価額</th>
                            <th class="text-right">含み損益</th>
                            <th class="text-right">投資期間</th>
                            <th class="text-right">推定XIRR</th>
                        </tr>
                    </thead>
                    <tbody id="assetTableBody">
                        <!-- Rows generated by JS -->
                    </tbody>
                </table>
            </div>
        </section>

        <!-- Process Log -->
        <section class="mb-8">
            <h3 class="text-sm font-bold text-slate-600 mb-2">処理ログ (System Log)</h3>
            <div id="processLog" class="log-container">
                <div class="log-entry">システム待機中... CSVファイルを読み込んでください。</div>
            </div>
        </section>

        <!-- AI Insight -->
        <section id="aiSection" class="bg-white rounded-xl border border-blue-200 shadow-sm overflow-hidden mb-8">
            <div class="bg-gradient-to-r from-blue-50 to-white px-6 py-4 border-b border-blue-100 flex items-center justify-between">
                <div class="flex items-center gap-2">
                    <div class="bg-blue-600 text-white p-1.5 rounded-lg shadow-sm">
                        <i data-lucide="sparkles" class="w-4 h-4"></i>
                    </div>
                    <h2 class="text-base font-bold text-blue-900">AI ポートフォリオ診断レポート</h2>
                </div>
                <div id="aiStatusBadge" class="flex items-center gap-2 px-3 py-1 bg-white rounded-full border border-blue-100 shadow-sm text-xs font-bold text-blue-600">
                    <span class="relative flex h-2 w-2">
                      <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-blue-400 opacity-75"></span>
                      <span class="relative inline-flex rounded-full h-2 w-2 bg-blue-500"></span>
                    </span>
                    Thinking...
                </div>
            </div>
            <div class="p-8">
                <div id="aiContent" class="prose-ai text-slate-600">
                    <div class="flex flex-col items-center justify-center h-32 text-slate-400 gap-3">
                        <i data-lucide="brain-circuit" class="w-10 h-10 opacity-20 animate-pulse"></i>
                        <p class="text-sm font-medium">データを分析し、インサイトを生成しています...</p>
                    </div>
                </div>
            </div>
        </section>

    </main>

    <script>
        // --- 1. Configuration & Constants ---
        const apiKey = ""; // API Key injected by environment
        
        // Name Mappings for Unification
        const NAME_MAPPINGS = {
            "eMAXIS Slim 全世界株式(オール・カントリー)": "eMAXIS Slim 全世界株式(オール・カントリー)(オルカン)",
            "eMAXIS Slim 先進国リートインデックス": "eMAXIS Slim 先進国リートインデックス(除く日本)"
        };

        const applyNameMapping = (name) => {
            if (!name) return "";
            const trimmed = name.trim();
            return NAME_MAPPINGS[trimmed] || trimmed;
        };

        // Colors for Charts
        const COLORS = {
            equity: '#3b82f6',   // Blue
            bond: '#10b981',     // Emerald
            reit: '#f59e0b',     // Amber
            commodity: '#eab308', // Yellow
            core: '#6366f1',     // Indigo
            satellite: '#f43f5e', // Rose
            bg: ['#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#06b6d4', '#ec4899', '#64748b']
        };

        let rawTransactions = [];
        let portfolio = []; // Aggregated by symbol
        let balanceData = []; // Data from assetbalance csv
        let exchangeRates = {}; // Extracted from balance csv
        let charts = {};
        
        // Logger
        const log = (msg, type = 'info') => {
            const div = document.getElementById('processLog');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type === 'success' ? 'log-success' : (type === 'warn' ? 'log-warn' : 'log-info')}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            div.appendChild(entry);
            div.scrollTop = div.scrollHeight;
        };

        // --- 2. Finance Math Functions (Newton-Raphson for XIRR) ---
        const Finance = {
            xirr: (cfs, guess = 0.1) => {
                cfs.sort((a, b) => a.date - b.date);
                if (cfs.length < 2) return 0;
                
                const t0 = cfs[0].date;
                const normalize = d => (d - t0) / (1000 * 60 * 60 * 24 * 365);
                
                let r = guess;
                const maxIter = 100;
                const tol = 1e-6;
                
                for (let i = 0; i < maxIter; i++) {
                    let fValue = 0;
                    let fDerivative = 0;
                    
                    for (const cf of cfs) {
                        const t = normalize(cf.date);
                        const discount = Math.pow(1 + r, t);
                        fValue += cf.amount / discount;
                        fDerivative -= (t * cf.amount) / (discount * (1 + r));
                    }
                    
                    if (Math.abs(fValue) < tol) return r;
                    if (Math.abs(fDerivative) < tol) return null;
                    
                    const newR = r - fValue / fDerivative;
                    if (Math.abs(newR - r) < tol) return newR;
                    r = newR;
                    if (r <= -1) r = -0.99;
                }
                return null;
            }
        };

        // --- 3. Data Processing ---
        
        const classifyAsset = (name, ticker) => {
            const n = (name || '').toUpperCase();
            if (n.match(/GOLD|GLD|IAU|SLV|金|プラチナ|コモディティ/)) return 'Commodity';
            if (n.match(/REIT|リート|不動産/)) return 'REIT';
            if (n.match(/BOND|債券|AGG|BND|TLT/)) return 'Bond';
            return 'Equity';
        };

        const parseCurrency = (val) => {
            if (!val) return 0;
            // Handle parentheses (Points): "5,000(493)" -> "5,000"
            let clean = String(val).split('(')[0].split('（')[0];
            clean = clean.replace(/[^-0-9.]/g, '');
            const num = parseFloat(clean);
            return isNaN(num) ? 0 : num;
        };

        const cleanNum = (val) => parseCurrency(val);

        const formatDate = (d) => {
            if (!d) return null;
            const date = new Date(d);
            return isNaN(date.getTime()) ? null : date;
        };

        // Specific Parser for Asset Balance CSV
        const parseAssetBalance = (data) => {
            let extracted = [];
            let rates = {};
            let headerFound = false;
            // Column Indices
            let colMap = { type: -1, code: -1, name: -1, qty: -1, qtyUnit: -1, price: -1, priceUnit: -1, value: -1 };
            
            log(`資産残高ファイルの解析を開始 (${data.length}行)`);

            for (let i = 0; i < data.length; i++) {
                const row = data[i];
                if (!row || row.length === 0) continue;
                const strRow = row.join(',');

                // 1. Exchange Rate Extraction
                if (strRow.includes('参考為替レート')) {
                    // Look ahead for USD
                    for (let j = 1; j < 5; j++) {
                        if (data[i+j]) {
                            const rateRow = data[i+j];
                            const rateIdx = rateRow.findIndex(c => c.includes('USD') || c.includes('米ドル'));
                            if (rateIdx !== -1 && rateRow[rateIdx+1]) {
                                const rate = cleanNum(rateRow[rateIdx+1]);
                                if (rate > 0) {
                                    rates['USD'] = rate;
                                    log(`為替レート検出: 1 USD = ${rate} JPY`, 'success');
                                }
                            }
                        }
                    }
                }

                // 2. Find Portfolio Header
                if (!headerFound) {
                    const hasType = row.some(c => c.includes('種別'));
                    const hasName = row.some(c => c.includes('銘柄'));
                    
                    if (hasType && hasName) {
                        headerFound = true;
                        
                        row.forEach((cell, idx) => {
                            if (cell.includes('種別')) colMap.type = idx;
                            if (cell.includes('コード') || cell.includes('ティッカー')) colMap.code = idx;
                            if (cell === '銘柄' || cell === '銘柄名' || cell === 'ファンド名') colMap.name = idx; // Exact match preferred
                            if (cell.includes('数量') || (cell.includes('保有') && cell.includes('数量'))) colMap.qty = idx;
                            if (cell.includes('現在値')) colMap.price = idx;
                            if (cell.includes('時価評価額') && cell.includes('円')) colMap.value = idx;
                        });

                        // Deduce Unit Columns (usually next to qty/price)
                        // If qty index is found, check if next is "単位"
                        if (colMap.qty !== -1 && row[colMap.qty + 1] && row[colMap.qty + 1].includes('単位')) {
                            colMap.qtyUnit = colMap.qty + 1;
                        }
                        if (colMap.price !== -1 && row[colMap.price + 1] && row[colMap.price + 1].includes('単位')) {
                            colMap.priceUnit = colMap.price + 1;
                        }

                        log(`資産詳細ヘッダーを検出: QtyIdx=${colMap.qty}, UnitIdx=${colMap.qtyUnit}, ValIdx=${colMap.value}`, 'info');
                    }
                    continue;
                }

                // 3. Read Data
                if (colMap.type === -1) continue;
                
                const type = row[colMap.type];
                if (!type) continue; // Skip empty rows or separators

                // Parse Values
                let qty = cleanNum(row[colMap.qty]);
                let value = cleanNum(row[colMap.value]);
                
                // --- UNIT PROCESSING ---
                // Rule: If unit is "口", divide qty by 10,000
                if (colMap.qtyUnit !== -1) {
                    const unit = (row[colMap.qtyUnit] || '').trim();
                    if (unit === '口') {
                        qty = qty / 10000;
                    }
                }
                
                if (value > 0) { 
                    extracted.push({
                        type: type,
                        code: row[colMap.code],
                        name: row[colMap.name],
                        qty: qty, // Adjusted Qty
                        value: value // Market Value in JPY
                    });
                }
            }
            log(`資産データ抽出完了: ${extracted.length}件`, 'info');
            return { items: extracted, rates: rates };
        };

        // Main Parser
        const parseFiles = async (files) => {
            const promises = Array.from(files).map(file => new Promise((resolve) => {
                Papa.parse(file, {
                    header: false,
                    skipEmptyLines: 'greedy',
                    encoding: 'Shift_JIS',
                    complete: (res) => {
                        resolve({ name: file.name, data: res.data });
                    }
                });
            }));

            const results = await Promise.all(promises);
            let txs = [];
            balanceData = [];
            exchangeRates = {};

            results.forEach(({ name, data }) => {
                const strData = JSON.stringify(data.slice(0, 20)); 
                
                // 1. Asset Balance?
                if (strData.includes('資産合計') || strData.includes('種別')) { // Relaxed check
                    const parsed = parseAssetBalance(data);
                    balanceData = balanceData.concat(parsed.items);
                    exchangeRates = { ...exchangeRates, ...parsed.rates };
                    log(`ファイル読み込み: ${name} (資産残高)`, 'success');
                    return;
                }

                // 2. Transaction History?
                let headerRowIdx = -1;
                let keys = [];
                for(let i=0; i<Math.min(data.length, 10); i++) {
                    if (data[i].includes('約定日') && (data[i].includes('銘柄名') || data[i].includes('ティッカー') || data[i].includes('ファンド名'))) {
                        headerRowIdx = i;
                        keys = data[i];
                        break;
                    }
                }

                if (headerRowIdx === -1) {
                    // Maybe skip log if it was balance file
                    return; 
                }

                const isUS = keys.includes('ティッカー');
                const isInvst = keys.includes('ファンド名');
                const isJP = keys.includes('銘柄コード') && !isUS;
                const fileType = isUS ? '米国株' : (isInvst ? '投資信託' : '日本株');
                
                log(`ファイル読み込み: ${name} (${fileType})`, 'success');

                // Check for Unit [口] in Header to adjust Qty
                // If header has "数量[口]" or similar
                const qtyHeaderIndex = keys.findIndex(k => k.includes('数量') && (k.includes('口') || k.includes('［口］')));
                const isUnitKuchi = qtyHeaderIndex !== -1;

                // Process rows
                let rowCount = 0;
                for(let i = headerRowIdx + 1; i < data.length; i++) {
                    const row = data[i];
                    if (row.length !== keys.length) continue;

                    let obj = {};
                    keys.forEach((k, idx) => obj[k] = row[idx]);

                    let tx = {};
                    if (isUS) {
                        tx.date = formatDate(obj['約定日']);
                        tx.symbol = obj['ティッカー'];
                        tx.name = obj['銘柄名'] || obj['ティッカー'];
                        tx.type = obj['売買区分'];
                        tx.qty = cleanNum(obj['数量［株］']);
                        
                        const rawAmountJPY = obj['受渡金額［円］'];
                        if (rawAmountJPY && rawAmountJPY !== '-' && rawAmountJPY !== '') {
                            tx.amountJPY = cleanNum(rawAmountJPY);
                        } else {
                            const usd = cleanNum(obj['受渡金額［USドル］']);
                            const rate = cleanNum(obj['為替レート']);
                            tx.amountJPY = Math.abs(usd * rate);
                        }
                    } else if (isInvst) {
                        tx.date = formatDate(obj['約定日']);
                        
                        // Apply Name Mapping immediately
                        let rawName = obj['ファンド名'];
                        let mappedName = applyNameMapping(rawName);
                        
                        tx.symbol = mappedName;
                        tx.name = mappedName;
                        tx.type = obj['取引'] || obj['取引区分'];
                        
                        let qty = cleanNum(obj['数量［口］']);
                        if (isUnitKuchi) qty = qty / 10000; // Normalize to 10k units basis
                        tx.qty = qty;

                        tx.amountJPY = parseCurrency(obj['受渡金額/(ポイント利用)[円]'] || obj['受渡金額［円］']);
                    } else if (isJP) {
                        tx.date = formatDate(obj['約定日']);
                        tx.symbol = obj['銘柄コード'];
                        tx.name = obj['銘柄名'];
                        tx.type = obj['売買区分'];
                        tx.qty = cleanNum(obj['数量［株］']);
                        tx.amountJPY = cleanNum(obj['受渡金額［円］']);
                    }

                    if (tx.date && (tx.amountJPY > 0 || tx.qty > 0)) {
                        const tType = (tx.type || '').trim();
                        if (tType.match(/買|再投資|積立/)) tx.side = 'BUY';
                        else if (tType.match(/売|解約/)) tx.side = 'SELL';
                        else tx.side = 'OTHER';

                        tx.assetClass = classifyAsset(tx.name, tx.symbol);
                        tx.market = isUS ? 'US' : (isInvst ? 'INVST' : 'JP');
                        txs.push(tx);
                        rowCount++;
                    }
                }
                log(`  -> 取引データ ${rowCount}件 抽出`, 'info');
            });

            return txs.sort((a, b) => a.date - b.date);
        };

        const processPortfolio = () => {
            const holdings = {};

            rawTransactions.forEach(tx => {
                const key = tx.symbol;
                if (!holdings[key]) {
                    holdings[key] = {
                        symbol: tx.symbol,
                        name: tx.name,
                        assetClass: tx.assetClass,
                        market: tx.market,
                        qty: 0,
                        invested: 0,
                        realizedPL: 0,
                        firstDate: tx.date,
                        lastDate: tx.date,
                        lastPrice: 0,
                        txs: [],
                        isPriceUpdated: false
                    };
                }
                const h = holdings[key];
                h.txs.push(tx);
                if (tx.date > h.lastDate) h.lastDate = tx.date;

                let unitPrice = 0;
                if (tx.qty > 0) unitPrice = (tx.amountJPY / tx.qty);

                if (tx.side === 'BUY') {
                    h.qty += tx.qty;
                    h.invested += tx.amountJPY;
                    h.lastPrice = unitPrice; 
                } else if (tx.side === 'SELL') {
                    const avgCost = h.invested / (h.qty + tx.qty); 
                    const costBasis = avgCost * tx.qty;
                    h.realizedPL += (tx.amountJPY - costBasis);
                    h.qty -= tx.qty;
                    h.invested -= costBasis;
                }
            });

            const today = new Date();
            portfolio = Object.values(holdings).map(h => {
                const holdingDays = (today - h.firstDate) / (1000 * 60 * 60 * 24);
                const isHeld = h.qty > 0.0001; 
                
                let strategy = 'Satellite';
                if (h.market === 'INVST') {
                    strategy = 'Core';
                } else {
                    if (isHeld || holdingDays >= 365) {
                        strategy = 'Core';
                    }
                }
                
                h.strategy = strategy;
                h.holdingDays = holdingDays;
                h.currentPrice = isHeld ? h.lastPrice : 0; 

                return h;
            }).filter(h => h.qty > 0.0001);

            mergeBalanceData();
            updateCalculations();
        };

        const mergeBalanceData = () => {
            if (balanceData.length === 0) {
                log('資産残高データがないため、現在価格は最終取引単価を使用します', 'warn');
                return;
            }

            log('資産残高データとの照合(マッチング)を開始します...', 'info');
            let matchCount = 0;

            const normalize = (str) => {
                if(!str) return '';
                return str.replace(/[Ａ-Ｚａ-ｚ０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0))
                          .replace(/\s+/g, '')
                          .toLowerCase();
            };

            const balanceMap = {};
            
            // AGGREGATION LOGIC
            balanceData.forEach(item => {
                let key = item.code ? normalize(item.code) : normalize(item.name);
                if (!key) key = normalize(item.name);

                if (!balanceMap[key]) {
                    balanceMap[key] = { value: 0, qty: 0, name: item.name, count: 0 };
                }
                balanceMap[key].value += item.value;
                balanceMap[key].qty += item.qty;
                balanceMap[key].count++;
            });

            portfolio.forEach(p => {
                let match = null;
                const pCode = normalize(p.symbol);
                const pName = normalize(p.name);

                if (balanceMap[pCode]) match = balanceMap[pCode];
                else if (balanceMap[pName]) match = balanceMap[pName];
                
                if (match) {
                    if (match.qty > 0) {
                        // PRICE CALCULATION from AGGREGATED DATA
                        // Use Aggregated Value and Aggregated Qty from Balance File
                        const impliedPrice = match.value / match.qty;
                        
                        p.currentValue = match.value;
                        p.qty = match.qty; // Overwrite qty to match balance reality
                        p.currentPrice = impliedPrice;
                        p.isPriceUpdated = true;
                        
                        matchCount++;
                        log(`[上書き成功] ${p.name}: 新単価 ${Math.floor(p.currentPrice)} (評価額合計 ${Math.floor(match.value)} / 数量合計 ${match.qty} / ${match.count}行合算)`, 'success');
                    }
                } else {
                    log(`[マッチ失敗] ${p.name}`, 'warn');
                }
            });
            log(`照合完了: ${matchCount} / ${portfolio.length} 銘柄の価格を更新しました`, 'success');
        };

        const updateCalculations = () => {
            let totalInvested = 0;
            let totalCurrentVal = 0;
            let totalRealized = 0;
            let globalCFs = [];

            portfolio.forEach(h => {
                h.currentValue = h.qty * h.currentPrice;
                h.unrealizedPL = h.currentValue - h.invested;
                
                totalInvested += h.invested;
                totalCurrentVal += h.currentValue;
                totalRealized += h.realizedPL;

                let symCFs = h.txs.map(tx => ({
                    date: tx.date,
                    amount: tx.side === 'BUY' ? -tx.amountJPY : tx.amountJPY
                }));

                symCFs.push({ date: new Date(), amount: h.currentValue });

                const xirr = Finance.xirr(symCFs);
                h.xirr = xirr !== null ? xirr : 0;
                
                globalCFs = globalCFs.concat(h.txs.map(tx => ({
                    date: tx.date,
                    amount: tx.side === 'BUY' ? -tx.amountJPY : tx.amountJPY
                })));
            });

            if (totalCurrentVal > 0) {
                globalCFs.push({ date: new Date(), amount: totalCurrentVal });
            }

            const portfolioXirr = Finance.xirr(globalCFs);
            
            document.getElementById('kpiTotalXirr').textContent = (portfolioXirr * 100).toFixed(2) + '%';
            document.getElementById('kpiCurrentValue').textContent = '¥' + Math.floor(totalCurrentVal).toLocaleString();
            document.getElementById('kpiInvested').textContent = '累計投資額: ¥' + Math.round(totalInvested).toLocaleString();
            document.getElementById('kpiUnrealizedPL').textContent = '¥' + Math.round(totalCurrentVal - totalInvested).toLocaleString();
            document.getElementById('kpiRealizedPL').textContent = '¥' + Math.round(totalRealized).toLocaleString();
            
            const totalRet = totalInvested > 0 ? ((totalCurrentVal - totalInvested) / totalInvested * 100) : 0;
            const badge = document.getElementById('kpiReturnRate');
            badge.textContent = (totalRet >= 0 ? '+' : '') + totalRet.toFixed(1) + '%';
            badge.className = `text-xs font-bold px-2 py-0.5 rounded-full ${totalRet >= 0 ? 'bg-emerald-100 text-emerald-700' : 'bg-red-100 text-red-700'}`;

            renderTable();
            renderCharts(portfolioXirr);
        };

        const renderTable = () => {
            const tbody = document.getElementById('assetTableBody');
            const search = document.getElementById('tableSearch').value.toLowerCase();
            tbody.innerHTML = '';

            const sorted = [...portfolio].sort((a, b) => b.currentValue - a.currentValue);

            sorted.forEach((h, idx) => {
                if (search && !h.name.toLowerCase().includes(search) && !h.symbol.toLowerCase().includes(search)) return;

                const tr = document.createElement('tr');
                tr.className = 'hover:bg-slate-50 transition-colors';
                
                const inputClass = h.isPriceUpdated ? 'input-price auto-updated' : 'input-price bg-white';
                const inputTitle = h.isPriceUpdated ? '資産残高ファイルから自動取得済み' : '手動入力が必要です';
                
                const avgCost = h.qty > 0 ? (h.invested / h.qty) : 0;

                tr.innerHTML = `
                    <td>
                        <div class="font-bold text-slate-700 flex items-center gap-2">
                            ${h.name}
                            ${h.isPriceUpdated ? '<span class="text-[10px] bg-green-100 text-green-700 px-1.5 py-0.5 rounded border border-green-200">自動</span>' : ''}
                        </div>
                        <div class="text-xs text-slate-400">${h.symbol}</div>
                    </td>
                    <td><span class="px-2 py-0.5 text-xs rounded bg-slate-100 text-slate-600 font-medium">${h.assetClass}</span></td>
                    <td><span class="px-2 py-0.5 text-xs rounded ${h.strategy === 'Core' ? 'bg-indigo-100 text-indigo-700' : 'bg-rose-100 text-rose-700'} font-medium">${h.strategy}</span></td>
                    <td class="text-right text-sm">${h.qty.toLocaleString(undefined, { maximumFractionDigits: 4 })}</td>
                    <td class="text-right text-sm">¥${avgCost.toLocaleString(undefined, { minimumFractionDigits: 3, maximumFractionDigits: 3 })}</td>
                    <td class="text-right bg-blue-50/30 border-l border-blue-100">
                        <input type="number" class="${inputClass}" data-idx="${portfolio.indexOf(h)}" value="${h.currentPrice}" step="0.0001" title="${inputTitle}">
                    </td>
                    <td class="text-right font-bold text-slate-700">¥${Math.floor(h.currentValue).toLocaleString()}</td>
                    <td class="text-right font-bold ${h.unrealizedPL >= 0 ? 'text-emerald-600' : 'text-red-500'}">¥${Math.floor(h.unrealizedPL).toLocaleString()}</td>
                    <td class="text-right text-sm text-slate-500">${Math.floor(h.holdingDays)}日</td>
                    <td class="text-right font-bold ${h.xirr >= 0 ? 'text-blue-600' : 'text-red-500'}">${(h.xirr * 100).toFixed(1)}%</td>
                `;
                tbody.appendChild(tr);
            });

            document.querySelectorAll('.input-price').forEach(input => {
                input.addEventListener('change', (e) => {
                    const idx = parseInt(e.target.dataset.idx);
                    const val = parseFloat(e.target.value);
                    if (!isNaN(val)) {
                        portfolio[idx].currentPrice = val;
                        portfolio[idx].isPriceUpdated = false;
                        updateCalculations(); 
                    }
                });
            });
        };

        // ... (Charts and AI functions remain same) ...
        const renderCharts = (totalXirr) => {
            const getCtx = (id) => document.getElementById(id).getContext('2d');
            const destroy = (id) => { if(charts[id]) charts[id].destroy(); };
            const createCard = (id, title, icon, parentId) => {
                if(document.getElementById('card-'+id)) return;
                const div = document.createElement('div');
                div.className = 'chart-card';
                div.id = 'card-'+id;
                div.innerHTML = `
                    <div class="flex items-center justify-between mb-2">
                        <h4 class="text-sm font-bold text-slate-600 flex items-center gap-2">
                            ${icon ? `<i data-lucide="${icon}" class="w-4 h-4 text-slate-400"></i>` : ''}
                            ${title}
                        </h4>
                    </div>
                    <div class="chart-container"><canvas id="${id}"></canvas></div>
                `;
                document.getElementById(parentId).appendChild(div);
                lucide.createIcons();
            };

            destroy('chartXirrGauge');
            charts['chartXirrGauge'] = new Chart(getCtx('chartXirrGauge'), {
                type: 'doughnut',
                data: {
                    labels: ['Return', 'Base'],
                    datasets: [{
                        data: [Math.min(Math.max(totalXirr * 100, 0), 100), 100 - Math.min(Math.max(totalXirr * 100, 0), 100)],
                        backgroundColor: ['#2563eb', '#e2e8f0'],
                        borderWidth: 0,
                        circumference: 180,
                        rotation: -90
                    }]
                },
                options: {
                    cutout: '80%',
                    plugins: { tooltip: { enabled: false }, legend: { display: false }, datalabels: { display: false } }
                }
            });

            // Grid 1
            const section1 = 'gridSection1';
            document.getElementById(section1).innerHTML = ''; 

            // C1 Asset Class
            createCard('c1', '資産クラス別 構成比', 'pie-chart', section1);
            const classData = aggregate(portfolio, 'assetClass', 'currentValue');
            charts['c1'] = new Chart(getCtx('c1'), {
                type: 'doughnut',
                data: {
                    labels: Object.keys(classData),
                    datasets: [{ data: Object.values(classData), backgroundColor: [COLORS.equity, COLORS.bond, COLORS.reit, COLORS.commodity] }]
                },
                options: { plugins: { legend: { position: 'right' } } }
            });

            // C2 Strategy
            createCard('c2', 'Core (長期) vs Satellite (短期) 比率', 'shield-check', section1);
            const stratData = aggregate(portfolio, 'strategy', 'currentValue');
            charts['c2'] = new Chart(getCtx('c2'), {
                type: 'pie',
                data: {
                    labels: Object.keys(stratData),
                    datasets: [{ data: Object.values(stratData), backgroundColor: [COLORS.core, COLORS.satellite] }]
                },
                options: { plugins: { legend: { position: 'right' } } }
            });

            // C3 Class XIRR
            createCard('c3', '資産クラス別 XIRR', 'bar-chart-2', section1);
            const classes = ['Equity', 'Bond', 'REIT', 'Commodity'];
            const classXirrs = classes.map(cls => {
                let cfs = [];
                let currentVal = 0;
                portfolio.filter(h => h.assetClass === cls).forEach(h => {
                    cfs = cfs.concat(h.txs.map(t => ({ date: t.date, amount: t.side === 'BUY' ? -t.amountJPY : t.amountJPY })));
                    if(h.qty > 0) currentVal += h.currentValue;
                });
                if(currentVal > 0) cfs.push({ date: new Date(), amount: currentVal });
                return Finance.xirr(cfs) || 0;
            });
            charts['c3'] = new Chart(getCtx('c3'), {
                type: 'bar',
                data: {
                    labels: classes,
                    datasets: [{ label: 'XIRR', data: classXirrs.map(v => v*100), backgroundColor: [COLORS.equity, COLORS.bond, COLORS.reit, COLORS.commodity] }]
                },
                options: { indexAxis: 'y', plugins: { legend: { display: false } } }
            });

            // Grid 2
            const section2 = 'gridSection2';
            document.getElementById(section2).innerHTML = '';

            // C4 Monthly Flow
            createCard('c4', '投資スタイル別 月次投資額推移', 'layers', section2);
            const monthlyFlow = {};
            rawTransactions.filter(t => t.side === 'BUY').forEach(t => {
                const k = t.date.toISOString().slice(0, 7);
                if(!monthlyFlow[k]) monthlyFlow[k] = { core: 0, sat: 0 };
                const p = portfolio.find(p => p.symbol === t.symbol);
                if(p && p.strategy === 'Core') monthlyFlow[k].core += t.amountJPY;
                else monthlyFlow[k].sat += t.amountJPY;
            });
            const months = Object.keys(monthlyFlow).sort();
            charts['c4'] = new Chart(getCtx('c4'), {
                type: 'bar',
                data: {
                    labels: months,
                    datasets: [
                        { label: 'Core', data: months.map(m => monthlyFlow[m].core), backgroundColor: COLORS.core, stack: 'st' },
                        { label: 'Satellite', data: months.map(m => monthlyFlow[m].sat), backgroundColor: COLORS.satellite, stack: 'st' }
                    ]
                },
                options: { scales: { x: { stacked: true }, y: { stacked: true } } }
            });

            // C5 Realized PL
            createCard('c5', '資産クラス別 確定損益', 'trending-up', section2);
            const plByClass = aggregate(portfolio, 'assetClass', 'realizedPL');
            charts['c5'] = new Chart(getCtx('c5'), {
                type: 'bar',
                data: {
                    labels: Object.keys(plByClass),
                    datasets: [{ label: '確定損益', data: Object.values(plByClass), backgroundColor: COLORS.reit }]
                }
            });

            // C6 Top XIRR
            createCard('c6', 'XIRR 上位5銘柄', 'award', section2);
            const top5 = [...portfolio].sort((a,b) => b.xirr - a.xirr).slice(0, 5);
            charts['c6'] = new Chart(getCtx('c6'), {
                type: 'bar',
                data: {
                    labels: top5.map(p => p.name.slice(0, 10)),
                    datasets: [{ label: 'XIRR (%)', data: top5.map(p => p.xirr * 100), backgroundColor: COLORS.bond }]
                },
                options: { indexAxis: 'y' }
            });

            // C7 Stacked Area
            createCard('c7', '投資スタイル累積構成比推移', 'area-chart', section2);
            let cumCore = 0; let cumSat = 0;
            const cumData = months.map(m => {
                cumCore += monthlyFlow[m].core;
                cumSat += monthlyFlow[m].sat;
                const total = cumCore + cumSat;
                return { c: total ? (cumCore/total)*100 : 0, s: total ? (cumSat/total)*100 : 0 };
            });
            charts['c7'] = new Chart(getCtx('c7'), {
                type: 'line',
                data: {
                    labels: months,
                    datasets: [
                        { label: 'Core %', data: cumData.map(d => d.c), borderColor: COLORS.core, backgroundColor: COLORS.core + '80', fill: true },
                        { label: 'Satellite %', data: cumData.map(d => d.s), borderColor: COLORS.satellite, backgroundColor: COLORS.satellite + '80', fill: true }
                    ]
                },
                options: { elements: { point: { radius: 0 } }, scales: { y: { min: 0, max: 100 } } }
            });

            // C8 Win Rate
            createCard('c8', '勝率 (売却済取引)', 'target', section2);
            const profitablePositions = portfolio.filter(p => p.realizedPL > 0).length;
            const totalClosed = portfolio.filter(p => p.realizedPL !== 0).length;
            const winRate = totalClosed > 0 ? (profitablePositions / totalClosed) * 100 : 0;
            charts['c8'] = new Chart(getCtx('c8'), {
                type: 'doughnut',
                data: {
                    labels: ['Win', 'Loss'],
                    datasets: [{ data: [winRate, 100-winRate], backgroundColor: [COLORS.equity, '#e2e8f0'] }]
                },
                options: { 
                    cutout: '70%', 
                    plugins: { title: { display: true, text: `${Math.round(winRate)}%`, font: { size: 24 } }, legend: { display: false } } 
                }
            });

            // C9 Scatter
            createCard('c9', '保有期間 vs リターン', 'scatter-chart', section2);
            charts['c9'] = new Chart(getCtx('c9'), {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: '銘柄',
                        data: portfolio.map(p => ({ x: p.holdingDays, y: p.xirr * 100 })),
                        backgroundColor: portfolio.map(p => p.strategy === 'Core' ? COLORS.core : COLORS.satellite)
                    }]
                },
                options: {
                    scales: { x: { title: { display: true, text: '保有期間 (日)' } }, y: { title: { display: true, text: 'XIRR (%)' } } }
                }
            });
        };

        const aggregate = (data, key, valKey) => {
            const res = {};
            data.forEach(d => {
                if(!res[d[key]]) res[d[key]] = 0;
                res[d[key]] += d[valKey];
            });
            return res;
        };

        const generateAiReport = async () => {
            if(portfolio.length === 0) return;
            const totalVal = portfolio.reduce((a,b)=>a+b.currentValue, 0);
            const kpiXirr = document.getElementById('kpiTotalXirr').textContent;
            const coreRatio = (portfolio.filter(p => p.strategy === 'Core').reduce((a,b)=>a+b.currentValue,0) / totalVal * 100).toFixed(1);
            const assetAlloc = aggregate(portfolio, 'assetClass', 'currentValue');
            const topAlloc = Object.entries(assetAlloc).sort((a,b)=>b[1]-a[1])[0][0];

            const prompt = `
            あなたはプロの投資顧問（IFA）です。以下のポートフォリオデータを分析し、投資家へアドバイスを行ってください。
            - 総資産評価額: ¥${totalVal.toLocaleString()}
            - 全体XIRR (年率): ${kpiXirr}
            - コア(長期)比率: ${coreRatio}% (目標は80%以上)
            - 最大アセットクラス: ${topAlloc}
            
            指示: Markdown形式で、1.健全性診断(80:20ルール)、2.パフォーマンス評価、3.リバランス提案 を記述してください。
            `;

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });
                const data = await response.json();
                const text = data.candidates?.[0]?.content?.parts?.[0]?.text || "分析に失敗しました。";
                document.getElementById('aiContent').innerHTML = marked.parse(text);
                document.getElementById('aiStatusBadge').innerHTML = '<i data-lucide="check-circle" class="w-4 h-4 mr-1"></i>完了';
                document.getElementById('aiStatusBadge').className = "flex items-center gap-2 px-3 py-1 bg-green-50 rounded-full border border-green-200 shadow-sm text-xs font-bold text-green-700";
            } catch (e) {
                console.error(e);
                document.getElementById('aiContent').textContent = "AI分析の生成中にエラーが発生しました。";
            }
        };

        const handleFiles = async (e) => {
            const files = e.target.files;
            if (files.length === 0) return;
            document.getElementById('loadingOverlay').classList.remove('hidden');
            document.getElementById('processLog').innerHTML = ''; // Clear log
            log('処理を開始します...');
            
            try {
                rawTransactions = await parseFiles(files);
                processPortfolio();
                document.getElementById('initialSplash').classList.add('hidden');
                document.getElementById('appHeader').classList.remove('hidden');
                document.getElementById('mainContent').classList.remove('hidden');
                generateAiReport();
            } catch (err) {
                console.error(err);
                log('エラーが発生しました: ' + err.message, 'warn');
                alert("ファイルの読み込みに失敗しました。形式を確認してください。");
            } finally {
                document.getElementById('loadingOverlay').classList.add('hidden');
            }
        };

        const exportPDF = async () => {
            const btn = document.getElementById('btnExportPdf');
            const originalText = btn.innerHTML;
            btn.innerHTML = `<i data-lucide="loader-2" class="w-3.5 h-3.5 animate-spin"></i> 生成中...`;
            try {
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF('p', 'mm', 'a4');
                const content = document.getElementById('mainContent');
                const canvas1 = await html2canvas(content, { scale: 1.5, height: 1200, windowWidth: 1400 });
                const imgData1 = canvas1.toDataURL('image/jpeg', 0.8);
                const pdfWidth = 210;
                const pdfHeight = (canvas1.height * pdfWidth) / canvas1.width;
                pdf.addImage(imgData1, 'JPEG', 0, 0, pdfWidth, pdfHeight);
                pdf.save('Portfolio_Report.pdf');
            } catch(e) {
                alert('PDF生成エラー: ' + e.message);
            } finally {
                btn.innerHTML = originalText;
                lucide.createIcons();
            }
        };

        window.onload = () => {
            lucide.createIcons();
            document.getElementById('csvFileInputSplash').addEventListener('change', handleFiles);
            document.getElementById('csvFileInputHeader').addEventListener('change', handleFiles);
            document.getElementById('btnExportPdf').addEventListener('click', exportPDF);
            document.getElementById('tableSearch').addEventListener('input', renderTable);
        };
    </script>
</body>
</html>